name: 칸반 - PR 이벤트 시 전환
description: PR이 열리거나 머지될 때 연결된 이슈를 이동합니다
inputs:
  mode:
    description: opened 또는 merged
    required: true
  org:
    description: 조직 로그인(organization 로그인)
    required: true
  project-number:
    description: 클래식 프로젝트 번호
    required: false
  project-name:
    description: 클래식 프로젝트 이름(번호가 없을 때 대체)
    required: false
  backlog:
    description: 백로그 컬럼 이름
    required: true
  planned:
    description: 작업 예정 컬럼 이름
    required: true
  in-progress:
    description: 작업중 컬럼 이름
    required: true
  review:
    description: 리뷰 대기 컬럼 이름
    required: true
  done:
    description: 완료 컬럼 이름
    required: true
  github-token:
    description: 조직 클래식 프로젝트 API 접근 토큰(PAT 권장). 미설정 시 GITHUB_TOKEN 사용
    required: false
    default: ${{ github.token }}
runs:
  using: composite
  steps:
    - name: PR 이벤트에 따른 상태 전환
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const mode = process.env.MODE;
            const expectEvent = (mode === 'opened') ? 'opened' : 'closed';
            if (!(context.eventName === 'pull_request' && context.payload.action === expectEvent)) {
              core.info(`PR 이벤트/모드 불일치(mode=${mode}): 건너뜀`);
              return;
            }
            if (mode === 'merged' && !context.payload.pull_request.merged) {
              core.info('PR이 닫혔지만 병합되지 않음: 건너뜀');
              return;
            }

            const ORG = process.env.ORG || process.env.GITHUB_REPOSITORY_OWNER;
            const PROJECT_NUMBER = process.env.PROJECT_NUMBER ? parseInt(process.env.PROJECT_NUMBER, 10) : undefined;
            const PROJECT_NAME = process.env.PROJECT_NAME || undefined;
            const COLUMN_NAMES = {
              backlog: process.env.BACKLOG,
              planned: process.env.PLANNED,
              inProgress: process.env.IN_PROGRESS,
              review: process.env.REVIEW,
              done: process.env.DONE,
            };

            const inertiaHeader = { accept: 'application/vnd.github.inertia-preview+json' };
            function extractIssueNumbersFromText(text) {
              const nums = new Set();
              if (!text) return [];
              const kw = /(close[sd]?|fix(e[sd])?|resolve[sd]?)\s+#(\d+)/ig;
              for (const match of text.matchAll(kw)) nums.add(parseInt(match[3], 10));
              const hash = /#(\d+)/g;
              for (const match of text.matchAll(hash)) nums.add(parseInt(match[1], 10));
              return [...nums];
            }
            function extractIssueNumbersFromBranch(ref) {
              if (!ref) return [];
              const nums = new Set();
              const m = ref.match(/(?:(?:^|[\/\-_]))(\d{1,6})(?=$|[\/\-_])/g);
              if (m) for (const s of m) {
                const n = parseInt(s.replace(/\D/g, ''), 10);
                if (!isNaN(n)) nums.add(n);
              }
              return [...nums];
            }

          async function getOrgProjectByNumberOrName(org, number, name) {
            try {
              const projects = await github.paginate(github.request, 'GET /orgs/{org}/projects', {
                org,
                per_page: 100,
                headers: inertiaHeader,
              });
              core.info(`조회된 프로젝트 목록: ${projects.map(p => `${p.number}:${p.name}`).join(', ')}`);
              const found = (number && projects.find(p => p.number === number)) || (name && projects.find(p => p.name === name));
              if (!found) { core.warning(`프로젝트를 찾지 못했습니다. number=${number}, name='${name}'`); return null; }
              return found;
            } catch (e) {
              core.warning(`프로젝트 조회 실패(org='${org}'): ${e.message}`);
              return null;
            }
          }

          async function getColumns(project_id) {
            const cols = await github.paginate(github.request, 'GET /projects/{project_id}/columns', {
              project_id,
              per_page: 100,
              headers: inertiaHeader,
            });
            core.info(`프로젝트(${project_id}) 컬럼들: ${cols.map(c => c.name).join(', ')}`);
            return cols;
          }

          async function getColumnIdByName(project_id, name) {
            const cols = await getColumns(project_id);
            const col = cols.find(c => c.name === name);
            if (!col) { core.warning(`컬럼을 찾지 못했습니다: ${name}`); return null; }
            return col.id;
          }

            async function findIssue(owner, repo, issue_number) {
              const { data } = await github.rest.issues.get({ owner, repo, issue_number });
              return data;
            }

            async function getIssueProjectCard(issue, project) {
              const cols = await getColumns(project.id);
              for (const col of cols) {
                const cards = await github.paginate(github.request, 'GET /projects/columns/{column_id}/cards', {
                  column_id: col.id,
                  per_page: 100,
                  headers: inertiaHeader,
                });
                const card = cards.find(card => card.content_url && card.content_url.endsWith(`/issues/${issue.number}`));
                if (card) return { card, column: col };
              }
              return null;
            }

            async function moveCardToColumn(card_id, to_column_id) {
              await github.request('POST /projects/columns/cards/{card_id}/moves', {
                card_id,
                column_id: to_column_id,
                position: 'top',
                headers: inertiaHeader,
              });
            }

            async function setIssueStatusLabel(owner, repo, issue_number, label) {
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              const allStatus = Object.values(COLUMN_NAMES);
              const existing = issue.labels.map(l => typeof l === 'string' ? l : l.name);
              const filtered = existing.filter(n => !allStatus.includes(n));
              const finalLabels = [...new Set([...filtered, label])];
              await github.rest.issues.update({ owner, repo, issue_number, labels: finalLabels });
            }

            const pr = context.payload.pull_request;
            const ref = pr?.head?.ref;
            const nums = new Set([
              ...extractIssueNumbersFromText(pr?.title || ''),
              ...extractIssueNumbersFromText(pr?.body || ''),
              ...extractIssueNumbersFromBranch(ref || ''),
            ]);
            if (!nums.size) { core.info('PR에 연결된 이슈 번호를 찾지 못함'); return; }

            const { owner, repo } = context.repo;
          const project = await getOrgProjectByNumberOrName(ORG, PROJECT_NUMBER, PROJECT_NAME);
          if (!project) { core.warning('프로젝트가 없어 이동을 건너뜁니다.'); return; }
          const targetColumnName = (mode === 'opened') ? COLUMN_NAMES.review : COLUMN_NAMES.done;
          const toColumnId = await getColumnIdByName(project.id, targetColumnName);
          if (!toColumnId) { core.warning('대상 컬럼을 찾지 못해 이동을 건너뜁니다.'); return; }

            for (const issue_number of nums) {
              try {
                const issue = await findIssue(owner, repo, issue_number);
                const cardInfo = await getIssueProjectCard(issue, project);
                if (!cardInfo) { core.info(`#${issue.number}에 연결된 카드가 없어 이동 건너뜀`); continue; }
                await moveCardToColumn(cardInfo.card.id, toColumnId);
                await setIssueStatusLabel(owner, repo, issue_number, targetColumnName);
                core.info(`#${issue_number} -> ${targetColumnName}`);
              } catch (e) {
                core.warning(`이동 실패 #${issue_number}: ${e.message}`);
              }
            }
      env:
        MODE: ${{ inputs.mode }}
        ORG: ${{ inputs.org }}
        PROJECT_NUMBER: ${{ inputs['project-number'] }}
        PROJECT_NAME: ${{ inputs['project-name'] }}
        BACKLOG: ${{ inputs.backlog }}
        PLANNED: ${{ inputs.planned }}
        IN_PROGRESS: ${{ inputs['in-progress'] }}
        REVIEW: ${{ inputs.review }}
        DONE: ${{ inputs.done }}
