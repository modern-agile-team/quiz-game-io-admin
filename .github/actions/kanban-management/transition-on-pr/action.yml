name: 칸반 - PR 이벤트 시 전환
description: PR이 열리거나 머지될 때 연결된 이슈를 이동합니다
inputs:
  mode:
    description: opened 또는 merged
    required: true
  org:
    description: 조직 로그인(organization 로그인)
    required: true
  project-number:
    description: 클래식 프로젝트 번호
    required: false
  project-name:
    description: 클래식 프로젝트 이름(번호가 없을 때 대체)
    required: false
  backlog:
    description: 백로그 컬럼 이름
    required: true
  planned:
    description: 작업 예정 컬럼 이름
    required: true
  in-progress:
    description: 작업중 컬럼 이름
    required: true
  review:
    description: 리뷰 대기 컬럼 이름
    required: true
  done:
    description: 완료 컬럼 이름
    required: true
  github-token:
    description: 조직 클래식 프로젝트 API 접근 토큰(PAT 권장). 미설정 시 GITHUB_TOKEN 사용
    required: false
    default: ${{ github.token }}
runs:
  using: composite
  steps:
    - name: PR 이벤트에 따른 상태 전환
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const mode = process.env.MODE;
          const expectEvent = (mode === 'opened') ? 'opened' : 'closed';
          if (!(context.eventName === 'pull_request' && context.payload.action === expectEvent)) {
            core.info(`PR 이벤트/모드 불일치(mode=${mode}): 건너뜀`);
            return;
          }
          if (mode === 'merged' && !context.payload.pull_request.merged) {
            core.info('PR이 닫혔지만 병합되지 않음: 건너뜀');
            return;
          }

          const ORG = process.env.ORG || context.repo.owner;
          core.info(`해결된 ORG: '${ORG}'`);
          const PROJECT_NUMBER = process.env.PROJECT_NUMBER ? parseInt(process.env.PROJECT_NUMBER, 10) : undefined;
          const PROJECT_NAME = process.env.PROJECT_NAME || undefined;
          const STATUS_MAP = {
            backlog: process.env.BACKLOG,
            planned: process.env.PLANNED,
            inProgress: process.env.IN_PROGRESS,
            review: process.env.REVIEW,
            done: process.env.DONE,
          };

          function extractIssueNumbersFromText(text) {
            const nums = new Set();
            if (!text) return [];
            const kw = /(close[sd]?|fix(e[sd])?|resolve[sd]?)\s+#(\d+)/ig;
            for (const match of text.matchAll(kw)) nums.add(parseInt(match[3], 10));
            const hash = /#(\d+)/g;
            for (const match of text.matchAll(hash)) nums.add(parseInt(match[1], 10));
            return [...nums];
          }
          function extractIssueNumbersFromBranch(ref) {
            if (!ref) return [];
            const nums = new Set();
            const m = ref.match(/(?:(?:^|[\/\-_]))(\d{1,6})(?=$|[\/\-_])/g);
            if (m) for (const s of m) {
              const n = parseInt(s.replace(/\D/g, ''), 10);
              if (!isNaN(n)) nums.add(n);
            }
            return [...nums];
          }

          const gql = String.raw;
          async function getProjectV2(org, number, name) {
            if (number) {
              const q = gql`query($org:String!,$num:Int!){ organization(login:$org){ projectV2(number:$num){ id title number fields(first:50){ nodes { __typename ... on ProjectV2FieldCommon { id name dataType } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }`;
              const r = await github.graphql(q, { org, num: number });
              const p = r?.organization?.projectV2;
              if (p) return p;
            }
            if (name) {
              const q = gql`query($org:String!){ organization(login:$org){ projectsV2(first:100){ nodes { id title number fields(first:50){ nodes { __typename ... on ProjectV2FieldCommon { id name dataType } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } } }`;
              const r = await github.graphql(q, { org });
              const p = r?.organization?.projectsV2?.nodes?.find(n => n.title === name);
              if (p) return p;
            }
            return null;
          }

          async function getIssueId(owner, repo, number) {
            const q = gql`query($owner:String!,$repo:String!,$num:Int!){ repository(owner:$owner,name:$repo){ issue(number:$num){ id } } }`;
            const r = await github.graphql(q, { owner, repo, num: number });
            return r?.repository?.issue?.id || null;
          }

          async function ensureItem(projectId, issueId) {
            const q = gql`query($id:ID!){ node(id:$id){ ... on Issue { projectItems(first:50){ nodes { id project{ id title number } } } } } }`;
            const r = await github.graphql(q, { id: issueId });
            const existing = r?.node?.projectItems?.nodes?.find(n => n.project?.id === projectId);
            if (existing) return existing.id;
            const m = gql`mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`;
            const res = await github.graphql(m, { projectId, contentId: issueId });
            return res?.addProjectV2ItemById?.item?.id;
          }

          function findStatusField(project) {
            const fields = project?.fields?.nodes || [];
            let field = fields.find(f => f.name === 'Status') || fields.find(f => f.name === '상태');
            if (!field) field = fields.find(f => (f.__typename === 'ProjectV2SingleSelectField'));
            return field;
          }

          async function setStatus(project, itemId, statusName) {
            const field = findStatusField(project);
            if (!field || !field.options) { core.warning('Status 필드를 찾지 못했거나 옵션이 없습니다.'); return; }
            const opt = field.options.find(o => o.name === statusName);
            if (!opt) { core.warning(`Status 옵션을 찾지 못했습니다: ${statusName}. 사용 가능: ${field.options.map(o=>o.name).join(', ')}`); return; }
            const m = gql`mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!){ updateProjectV2ItemFieldValue(input:{ projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$optionId }}){ projectV2Item { id } } }`;
            await github.graphql(m, { projectId: project.id, itemId, fieldId: field.id, optionId: opt.id });
          }

          const pr = context.payload.pull_request;
          const ref = pr?.head?.ref;
          const nums = new Set([
            ...extractIssueNumbersFromText(pr?.title || ''),
            ...extractIssueNumbersFromText(pr?.body || ''),
            ...extractIssueNumbersFromBranch(ref || ''),
          ]);
          if (!nums.size) { core.info('PR에 연결된 이슈 번호를 찾지 못함'); return; }

          const { owner, repo } = context.repo;
          const project = await getProjectV2(ORG, PROJECT_NUMBER, PROJECT_NAME);
          if (!project) { core.warning('Projects(v2) 프로젝트를 찾지 못해 이동을 건너뜁니다.'); return; }
          const targetStatus = (mode === 'opened') ? STATUS_MAP.review : STATUS_MAP.done;

          for (const issue_number of nums) {
            try {
              const issueId = await getIssueId(owner, repo, issue_number);
              if (!issueId) { core.warning(`#${issue_number} 이슈 ID 없음`); continue; }
              const itemId = await ensureItem(project.id, issueId);
              if (!itemId) { core.warning(`#${issue_number} 아이템 생성/확인 실패`); continue; }
              await setStatus(project, itemId, targetStatus);
              // 라벨 동기화
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              const allStatus = Object.values(STATUS_MAP);
              const existing = issue.labels.map(l => typeof l === 'string' ? l : l.name);
              const filtered = existing.filter(n => !allStatus.includes(n));
              const finalLabels = [...new Set([...filtered, targetStatus])];
              await github.rest.issues.update({ owner, repo, issue_number, labels: finalLabels });
              core.info(`#${issue_number} -> ${targetStatus}`);
            } catch (e) {
              core.warning(`상태 갱신 실패 #${issue_number}: ${e.message}`);
            }
          }
      env:
        MODE: ${{ inputs.mode }}
        ORG: ${{ inputs.org }}
        PROJECT_NUMBER: ${{ inputs['project-number'] }}
        PROJECT_NAME: ${{ inputs['project-name'] }}
        BACKLOG: ${{ inputs.backlog }}
        PLANNED: ${{ inputs.planned }}
        IN_PROGRESS: ${{ inputs['in-progress'] }}
        REVIEW: ${{ inputs.review }}
        DONE: ${{ inputs.done }}
